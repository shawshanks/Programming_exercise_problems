# 动态数组
## 动态数组的作用
Python的 list 当被构建时,有特定的长度,但是list允许我们不断向list中append元素,好像对list的长度没有明确的限制.  
为了提供这种抽象,Python使用了 **动态数组** 算法.

底层实现可以分为两个部分:
1. 当一个列表实例被初始化时, Python一般会分配比当前元素数量更多的容量的compact array
2. 当后续元素超过compact array分配的容量时, Python会向系统申请更多容量的compact array,一般是当前数组容量的两倍. 然后把当前数组中的元素复制到新分配
的数组中. 然后这个数组就可以被回收了.

## 代码实现
### 状态字段
每个Python对象都会维持一些状态,比如列表:
`_n` : 列表中当前的实际元素数量
`_capacity`: 列表的容量
`_A`: 对当前数组的引用(即地址指针)
###
```python
import ctypes

class DynamicArray:
    """模仿Python list的动态数组类"""
    
    def __init__(self):
        """创建新的空数组"""
        self._n = 0                 # 元素数量计数
        self._capacity = 1          # 默认数组容量
        self._A = self._make_array(self._capacity)  # 底层数组实现
        
    def __len__(self):
        return self.n
     
    def __getitem__(self, k):
        """返回索引k处的元素""""
        if not(k >= 0 and k < self.n):
            raise IndexError('invalid index')
        return self._A[k]           # 检索
        
    def append(self, obj):
        """添加对象到数组的末端"""
        if self._n == self._capacity:           # 如果容量已满
           slef._resize(2 * self.capacity)      # 重新分配数组
        else:
           self._A[self._n] = obj               # 添加元素
           self._n += 1                         # 更新状态字段
    
    def _resize(self, c):
        new_array = self._make_array(c)         # 创建新的底层数组
        for i in range(self._n):                # 把列表中的元素复制到新数组中
            new_array[i] = slef.A[i]
        self.new_array = self._A                # 建立别名,之后用 new_array来支持列表
        self._cappacity = c                     # 更新相关状态字段
        
    def _make_array(self, c):
        """返回新数组"""
        return (c* cytes.py_object)()
           
  ```







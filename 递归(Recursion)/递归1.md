## 递归的描述定义
递归是一项技术: 一个函数在执行过程中调用了自身一次或多次, 每次执行都依靠 在结构类型 上完全一样的,但是更小的实例.

**递归的目的或者说作用**: 将问题切分为更小的问题,然后依次解决,最终达到解决问题
## 递归的数学定义
比如说 阶乘可以用递归定义:
 n!      = 1, if n = 0
         = (n-1)!, if n >= 1 
这个定义就是典型的递归定义.
首先, 递归包含一个或更多个 **基线条件(base cases)**: 例如 上面的 if n = 0. 满足这些条件时函数将直接`返回`一个值, n! =1,从而终止递归. 没有base cases的递归将会无线调用自身,不能终止,这将导致程序的崩溃.
其次, 递归还包含一个或多个**递归条件(recursive cases)**: 例如上面的 if n >=1, n! = (n-1)!, 这部分的定义依靠于函数自身最初的定义.

那么我们将上面的`数学定义`转化成`编程定义`:
```python
def facorial(n):
    if n = 0:
        return 1
    else:
        factorial(n-1)
```
##先从一道有关递归的题开始吧.
LeetCode上的一道题: [Maximum Binary Tree](https://leetcode.com/problems/maximum-binary-tree/)
题目的意思是:
给定一个无重复元素的整数数组,根据这个数组中的元素创建一个最大树:
1. 树的根是这个数组中最大的数,然后这个最大的数将数组分成左右两个部分
2. 树的左子树是左边数组中最大的整数
3. 树的柚子树是右边数组中最大的整数

### 解法思路
使用递归:
在数组中找出最大数, 并设为根节点

### 解法

```python
# 题目中的数明显是二叉数,所以先创建一个二叉树的类
class TreeNode:
    # 树节点构造器
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def constructMaximumBinaryTree(self, nums: list[int]) -> TreeNode:
        if len(nums)  == 0:
            return None
        max_i = 0
        
        for i in range(len(nums)):
            if nums[i] > nums[max_i]:
                max_i = i
        n = TreeNode(nums[max_i])
        
        n.left = self.constructMaximumBinaryTree(nums[0:max_i])
        n.right = self.constructMaximumBinaryTree(nums[max_i+1:])
        
        return n
     
```
